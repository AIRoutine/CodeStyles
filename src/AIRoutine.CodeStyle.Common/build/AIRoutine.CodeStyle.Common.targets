<Project>
  <!--
    AIRoutine.CodeStyle.Common - C# Code Style Validation
    Enforces DI-friendly patterns by forbidding direct static method calls.

    ALLOWED:
      - System.* and Microsoft.* namespace calls (framework APIs)
      - Extension methods (syntactically look like instance calls)
      - Language features: nameof(), typeof(), default(), sizeof()
      - Enum access and constants
      - Static property access on framework types

    FORBIDDEN:
      - Static method calls on custom/third-party types
      - Example: MyHelper.Calculate(), StringUtils.Format()
  -->

  <Target Name="ValidateNoStaticCalls"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <!-- Collect C# files, exclude obj/bin folders and generated files -->
      <_CSharpFilesForStaticValidation Include="$(MSBuildProjectDirectory)\**\*.cs"
                                        Exclude="$(MSBuildProjectDirectory)\obj\**\*.cs;$(MSBuildProjectDirectory)\bin\**\*.cs;$(MSBuildProjectDirectory)\**\*.g.cs;$(MSBuildProjectDirectory)\**\*.designer.cs;$(MSBuildProjectDirectory)\**\GlobalUsings.cs" />
    </ItemGroup>

    <ValidateCSharpNoStaticCalls
      CSharpFiles="@(_CSharpFilesForStaticValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate C# files for forbidden static method calls
    Detects:
      - Static method invocations on non-System/Microsoft types
      - Pattern: ClassName.MethodName( where ClassName is PascalCase
    Allows:
      - System.*, Microsoft.* namespace types
      - Extension methods (called on instances)
      - Language constructs: nameof, typeof, default, sizeof, checked, unchecked
      - Attribute usage
      - Enum values and constants
      - Generic type parameters
  -->
  <UsingTask TaskName="ValidateCSharpNoStaticCalls" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <CSharpFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Allowed type prefixes (System and Microsoft namespaces)
        var allowedPrefixes = new HashSet<string>(StringComparer.Ordinal)
        {
          // System namespace types
          "Console", "Convert", "Math", "Environment", "GC", "BitConverter",
          "Array", "Enum", "Type", "Activator", "AppDomain", "AppContext",
          "Buffer", "RuntimeHelpers", "MemoryMarshal", "Unsafe", "Vector",
          "String", "Char", "Int32", "Int64", "Double", "Decimal", "Boolean",
          "DateTime", "DateTimeOffset", "TimeSpan", "Guid", "Uri", "Version",
          "Path", "File", "Directory", "FileInfo", "DirectoryInfo", "Stream",
          "Task", "ValueTask", "Parallel", "Interlocked", "Volatile", "Thread",
          "Monitor", "Mutex", "Semaphore", "SpinLock", "SpinWait", "Barrier",
          "Lazy", "ThreadPool", "CancellationToken", "CancellationTokenSource",
          "Encoding", "Regex", "JsonSerializer", "XmlSerializer",
          "Debug", "Trace", "Debugger", "StackTrace", "Process",
          "Assembly", "MethodBase", "FieldInfo", "PropertyInfo", "EventInfo",
          "Attribute", "Marshal", "NativeMemory", "OperatingSystem",
          "Random", "RandomNumberGenerator", "HashCode",
          "EqualityComparer", "Comparer", "StringComparer",
          "Enumerable", "Queryable", "AsyncEnumerable",
          "Observable", "Observer",
          "ImmutableArray", "ImmutableList", "ImmutableDictionary", "ImmutableHashSet",
          "MemoryExtensions", "CollectionsMarshal", "RuntimeMarshal",
          "JsonDocument", "JsonElement", "JsonNode", "JsonValue", "JsonObject", "JsonArray",
          "Span", "Memory", "ReadOnlySpan", "ReadOnlyMemory",
          "Range", "Index", "HashSet", "SortedSet",
          "Tuple", "ValueTuple", "KeyValuePair",
          "EventArgs", "EventHandler", "Action", "Func", "Predicate",
          "WeakReference", "ConditionalWeakTable",
          "FormattableString", "MemoryPool", "ArrayPool",
          "BinaryPrimitives", "SequenceReader",
          "CultureInfo", "NumberFormatInfo", "DateTimeFormatInfo", "TextInfo",
          "TimeZoneInfo", "Calendar",
          "IPAddress", "IPEndPoint", "Dns", "Socket", "NetworkStream",
          "HttpClient", "WebRequest", "WebClient",
          "X509Certificate", "X509Certificate2", "RSA", "ECDsa", "Aes",
          "SHA256", "SHA384", "SHA512", "MD5", "HMACSHA256",
          "SymmetricAlgorithm", "AsymmetricAlgorithm",
          "SecureString", "ProtectedData",
          "ResourceManager", "CultureInfo",
          "Stopwatch", "PerformanceCounter",

          // Common BCL static types
          "BitOperations", "Enumerable", "ParallelEnumerable",
          "Expression", "RuntimeFeature", "RuntimeInformation",
          "DispatchProxy", "FormatterServices",

          // Microsoft namespace types
          "ServiceDescriptor", "Options", "OptionsBuilder",
          "Log", "Logger", "LoggerMessage",
          "Assert", "CollectionAssert", "StringAssert",
          "DependencyContext", "PlatformServices",
          "RuntimeEnvironment", "DotNetCli",

          // Entity Framework
          "EF",

          // ASP.NET Core
          "Results", "TypedResults", "WebApplication",

          // Commonly used framework extensions
          "ActivatorUtilities", "ObjectFactory",

          // Analyzers & Build
          "RulesetToEditorconfigConverter",

          // Testing frameworks (should be allowed)
          "Assert", "Verify", "Mock", "Substitute", "Fake", "A", "An"
        };

        // Language constructs that look like static calls but aren't
        var languageConstructs = new HashSet<string>(StringComparer.Ordinal)
        {
          "nameof", "typeof", "sizeof", "default", "checked", "unchecked",
          "stackalloc", "throw", "await", "new", "is", "as", "ref", "out", "in"
        };

        // Common attribute classes (used in attribute syntax [Attr])
        var attributeNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
          "Obsolete", "Conditional", "DebuggerDisplay", "DebuggerBrowsable",
          "Serializable", "NonSerialized", "DataContract", "DataMember",
          "JsonProperty", "JsonIgnore", "JsonPropertyName", "JsonInclude",
          "Required", "StringLength", "Range", "RegularExpression",
          "XmlElement", "XmlAttribute", "XmlRoot", "XmlType",
          "DllImport", "StructLayout", "MarshalAs", "FieldOffset",
          "MethodImpl", "CallerMemberName", "CallerFilePath", "CallerLineNumber",
          "InternalsVisibleTo", "AssemblyVersion", "AssemblyTitle",
          "GeneratedCode", "CompilerGenerated", "ExcludeFromCodeCoverage",
          "TestClass", "TestMethod", "Fact", "Theory", "InlineData",
          "SetUp", "TearDown", "Test", "TestCase", "TestFixture"
        };

        // Pattern for static method call: ClassName.MethodName(
        // Must start with uppercase letter, followed by alphanumerics
        // Excludes: string literals, comments, attributes, nameof/typeof
        var staticCallPattern = new Regex(
          @"\b([A-Z][a-zA-Z0-9_]*)\s*\.\s*([A-Z][a-zA-Z0-9_]*)\s*\(",
          RegexOptions.Compiled);

        // Pattern to detect if we're inside a string literal (simplified)
        var stringLiteralPattern = new Regex(
          @"""[^""]*""",
          RegexOptions.Compiled);

        // Pattern for generic type usage: SomeType<T>.Method(
        var genericTypePattern = new Regex(
          @"\b([A-Z][a-zA-Z0-9_]*)\s*<[^>]+>\s*\.\s*([A-Z][a-zA-Z0-9_]*)\s*\(",
          RegexOptions.Compiled);

        // Pattern for using static directives
        var usingStaticPattern = new Regex(
          @"^\s*using\s+static\s+",
          RegexOptions.Compiled);

        var violations = new List<string>();

        foreach (var file in CSharpFiles)
        {
          var filePath = file.ItemSpec;

          if (!File.Exists(filePath))
            continue;

          var lines = File.ReadAllLines(filePath);
          var usingStaticTypes = new HashSet<string>(StringComparer.Ordinal);
          var inMultiLineComment = false;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track multi-line comments
            if (line.Contains("/*") && !line.Contains("*/"))
              inMultiLineComment = true;
            if (line.Contains("*/"))
              inMultiLineComment = false;
            if (inMultiLineComment)
              continue;

            // Skip single-line comments
            var trimmed = line.TrimStart();
            if (trimmed.StartsWith("//"))
              continue;

            // Track using static directives (these types are allowed)
            if (usingStaticPattern.IsMatch(line))
            {
              var parts = line.Split(new[] { ' ', ';' }, StringSplitOptions.RemoveEmptyEntries);
              if (parts.Length >= 3)
              {
                var typeParts = parts[2].Split('.');
                if (typeParts.Length > 0)
                  usingStaticTypes.Add(typeParts[typeParts.Length - 1]);
              }
              continue;
            }

            // Skip attribute lines
            if (trimmed.StartsWith("[") && !trimmed.Contains("="))
              continue;

            // Remove string literals from analysis
            var lineWithoutStrings = stringLiteralPattern.Replace(line, "\"\"");

            // Remove single-line comment portion
            var commentIndex = lineWithoutStrings.IndexOf("//");
            if (commentIndex >= 0)
              lineWithoutStrings = lineWithoutStrings.Substring(0, commentIndex);

            // Skip lines that are primarily comments
            if (string.IsNullOrWhiteSpace(lineWithoutStrings))
              continue;

            // Skip lines with lambda arrow followed by static call (often valid patterns)
            if (lineWithoutStrings.Contains("=>") && lineWithoutStrings.IndexOf("=>") < lineWithoutStrings.LastIndexOf("."))
            {
              // Check if this is a simple lambda that might use allowed static methods
              // e.g., x => Console.WriteLine(x)
              // We'll still check these but be more lenient
            }

            // Check for standard static calls: ClassName.MethodName(
            var matches = staticCallPattern.Matches(lineWithoutStrings);
            foreach (Match match in matches)
            {
              var className = match.Groups[1].Value;
              var methodName = match.Groups[2].Value;

              // Skip language constructs
              if (languageConstructs.Contains(className.ToLowerInvariant()))
                continue;

              // Skip allowed prefixes (System/Microsoft types)
              if (allowedPrefixes.Contains(className))
                continue;

              // Skip if type is from using static
              if (usingStaticTypes.Contains(className))
                continue;

              // Skip attribute-like patterns
              if (attributeNames.Contains(className))
                continue;

              // Skip enum-like patterns (all caps or ending with common enum suffixes)
              if (className.All(c => char.IsUpper(c) || c == '_') ||
                  className.EndsWith("Type") || className.EndsWith("Kind") ||
                  className.EndsWith("Mode") || className.EndsWith("State") ||
                  className.EndsWith("Status") || className.EndsWith("Level") ||
                  className.EndsWith("Option") || className.EndsWith("Options") ||
                  className.EndsWith("Flags"))
              {
                // Check if method name looks like an enum value (PascalCase without open paren)
                if (char.IsUpper(methodName[0]) && !methodName.Contains("("))
                  continue;
              }

              // Skip if looks like generic type constraint or where clause
              if (line.Contains("where ") && line.Contains(":"))
                continue;

              // This is a potential violation
              violations.Add($"{filePath}({lineNum}): Static call '{className}.{methodName}()' is not allowed. Use dependency injection with a service interface instead. Only System.*/Microsoft.* static calls are permitted.");
            }

            // Check for generic static calls: ClassName<T>.MethodName(
            var genericMatches = genericTypePattern.Matches(lineWithoutStrings);
            foreach (Match match in genericMatches)
            {
              var className = match.Groups[1].Value;
              var methodName = match.Groups[2].Value;

              // Skip language constructs
              if (languageConstructs.Contains(className.ToLowerInvariant()))
                continue;

              // Skip allowed prefixes
              if (allowedPrefixes.Contains(className))
                continue;

              // Skip common framework generic types
              if (className == "Enumerable" || className == "Queryable" ||
                  className == "Task" || className == "ValueTask" ||
                  className == "Nullable" || className == "EqualityComparer" ||
                  className == "Comparer" || className == "Activator" ||
                  className == "Array" || className == "List" ||
                  className == "Dictionary" || className == "HashSet" ||
                  className == "ImmutableArray" || className == "ImmutableList" ||
                  className == "ImmutableDictionary" || className == "ImmutableHashSet" ||
                  className == "Observable" || className == "Optional" ||
                  className == "Result" || className == "Option")
                continue;

              violations.Add($"{filePath}({lineNum}): Static call '{className}<T>.{methodName}()' is not allowed. Use dependency injection with a service interface instead. Only System.*/Microsoft.* static calls are permitted.");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

</Project>
