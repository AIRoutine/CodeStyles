<Project>
  <!--
    AIRoutine.CodeStyle.Uno - XAML Style and Color Validation
    Best Practices:
      - All UI controls must have explicit Style references
      - All colors must be defined in ResourceDictionary and referenced via StaticResource/ThemeResource
    See: https://platform.uno/docs/articles/external/uno.themes/doc/lightweight-styling.html
  -->

  <PropertyGroup>
    <!--
      =============================================
      VALIDATION SETTINGS - ALL RULES ENFORCED AS ERRORS
      =============================================
      All validations are ALWAYS enabled and report as ERRORS.
      No configuration options - install the package to enforce all rules.
    -->
    <UnoCodeStyleAllowedSpacingValues Condition="'$(UnoCodeStyleAllowedSpacingValues)' == ''">0,2,4,8,12,16,20,24,32,48,64</UnoCodeStyleAllowedSpacingValues>
  </PropertyGroup>

  <Target Name="ValidateNoHardcodedColors"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <!-- Collect XAML files, exclude obj/bin folders and ResourceDictionary files -->
      <_XamlFilesToValidate Include="$(MSBuildProjectDirectory)\**\*.xaml"
                             Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <!-- Validate XAML files -->
    <ValidateXamlNoHardcodedColors
      XamlFiles="@(_XamlFilesToValidate)"
      Severity="error" />

    <!-- C# color validation is now handled by Roslyn Analyzer ACS0003 -->
  </Target>

  <!--
    Inline Task: Validate XAML files for hardcoded colors
    Detects:
      - Hex colors: #RGB, #RRGGBB, #AARRGGBB (case insensitive)
      - Named colors in attributes: Color="Red", Background="Blue", etc.
      - Excludes: x:Key definitions (ResourceDictionary entries are allowed)
  -->
  <UsingTask TaskName="ValidateXamlNoHardcodedColors" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Pattern for hex colors (not inside StaticResource/ThemeResource/x:Key context)
        var hexColorPattern = new Regex(
          @"(?<!(StaticResource|ThemeResource|x:Key)\s*=\s*"")[""']?\s*#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})\b",
          RegexOptions.IgnoreCase);

        // Pattern for detecting attribute assignments with hex colors
        var attributeHexPattern = new Regex(
          @"(Color|Background|Foreground|Fill|Stroke|BorderBrush|Tint)\s*=\s*""#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})""",
          RegexOptions.IgnoreCase);

        // Pattern for named colors in attributes (common WinUI/UWP color names)
        var namedColorPattern = new Regex(
          @"(Color|Background|Foreground|Fill|Stroke|BorderBrush)\s*=\s*""(AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenrod|DarkGray|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGray|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGray|DodgerBlue|Firebrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|Goldenrod|Gray|Green|GreenYellow|Honeydew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenrodYellow|LightGray|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGray|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquamarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenrod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGray|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)""",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary files (these are where colors SHOULD be defined)
          if (fileName.Contains("Resources") || fileName.Contains("Theme") || fileName.Contains("Colors") || fileName.Contains("Brushes"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);
          var lines = File.ReadAllLines(filePath);

          // Check if this file is a ResourceDictionary (allowed to have color definitions)
          if (content.Contains("<ResourceDictionary") || content.Contains("x:Key="))
          {
            // For ResourceDictionaries, only flag colors that are NOT in x:Key context
            // This is complex, so we skip ResourceDictionary files entirely
            if (content.Contains("<ResourceDictionary"))
              continue;
          }

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Skip lines with x:Key (these are resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Skip lines with StaticResource or ThemeResource (these are correct usage)
            if (line.Contains("StaticResource") || line.Contains("ThemeResource"))
              continue;

            // Check for hex colors in attributes
            var hexMatches = attributeHexPattern.Matches(line);
            foreach (Match match in hexMatches)
            {
              violations.Add($"{filePath}({lineNum}): Hardcoded hex color '{match.Value}' detected. Use StaticResource or ThemeResource instead.");
            }

            // Check for named colors
            var namedMatches = namedColorPattern.Matches(line);
            foreach (Match match in namedMatches)
            {
              violations.Add($"{filePath}({lineNum}): Hardcoded named color '{match.Value}' detected. Use StaticResource or ThemeResource instead.");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!-- C# color validation (ValidateCSharpNoHardcodedColors) removed - now handled by Roslyn Analyzer ACS0003 -->

  <!--
    =============================================
    Style Validation: All UI controls must have explicit Style references
    =============================================
  -->

  <Target Name="ValidateControlStyles"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <!-- Collect XAML files, exclude obj/bin folders and ResourceDictionary files -->
      <_XamlFilesForStyleValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                     Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <!-- Validate XAML files for missing styles -->
    <ValidateXamlControlStyles
      XamlFiles="@(_XamlFilesForStyleValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for missing Style attributes on UI controls
    Detects UI controls without Style="{StaticResource ...}" or Style="{ThemeResource ...}"

    Validated Controls:
      - Button, RepeatButton, ToggleButton, HyperlinkButton, DropDownButton, SplitButton, ToggleSplitButton
      - TextBlock, TextBox, PasswordBox, RichEditBox, AutoSuggestBox, NumberBox
      - ComboBox, ListView, GridView, ListBox, FlipView, TreeView, ItemsRepeater
      - CheckBox, RadioButton, ToggleSwitch, Slider, RatingControl, ProgressBar, ProgressRing
      - Border, Grid, StackPanel, RelativePanel, Canvas (optional - layout panels)
      - Image, MediaPlayerElement, PersonPicture, CalendarView, DatePicker, TimePicker
      - NavigationView, TabView, MenuBar, CommandBar, AppBar
      - ContentDialog, Flyout, MenuFlyout, TeachingTip, InfoBar
      - And more...

    Exclusions:
      - Elements with x:Key (Style definitions in ResourceDictionary)
      - ResourceDictionary files
      - Elements inside DataTemplate, ControlTemplate, or Style definitions
  -->
  <UsingTask TaskName="ValidateXamlControlStyles" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // UI Controls that MUST have a Style attribute
        var controlsRequiringStyle = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
          // Buttons
          "Button", "RepeatButton", "ToggleButton", "HyperlinkButton", "DropDownButton",
          "SplitButton", "ToggleSplitButton", "AppBarButton", "AppBarToggleButton",

          // Text Controls
          "TextBlock", "TextBox", "PasswordBox", "RichEditBox", "RichTextBlock",
          "AutoSuggestBox", "NumberBox",

          // Selection Controls
          "ComboBox", "ListBox", "ListView", "GridView", "FlipView", "TreeView",
          "ItemsRepeater", "Selector",

          // Toggle Controls
          "CheckBox", "RadioButton", "ToggleSwitch",

          // Range Controls
          "Slider", "RatingControl", "ProgressBar", "ProgressRing",

          // Date/Time Controls
          "CalendarView", "CalendarDatePicker", "DatePicker", "TimePicker",

          // Media Controls
          "Image", "MediaPlayerElement", "PersonPicture", "BitmapIcon", "FontIcon",
          "SymbolIcon", "PathIcon", "ImageIcon",

          // Navigation Controls
          "NavigationView", "TabView", "Pivot", "PivotItem", "Hub", "HubSection",
          "MenuBar", "MenuBarItem", "CommandBar", "AppBar",

          // Dialog/Overlay Controls
          "ContentDialog", "Flyout", "MenuFlyout", "TeachingTip", "InfoBar", "Popup",

          // Container Controls (strict mode includes these)
          "Border", "ContentPresenter", "ContentControl", "Frame",
          "ScrollViewer", "ScrollContentPresenter", "Viewbox",
          "Expander", "SplitView", "NavigationViewItem",

          // Input Controls
          "ColorPicker", "InkCanvas", "InkToolbar", "MapControl",

          // List Items
          "ListViewItem", "GridViewItem", "TreeViewItem", "ComboBoxItem", "ListBoxItem"
        };

        // Pattern to match opening tags of controls
        var controlTagPattern = new Regex(
          @"<\s*(\w+:)?(" + string.Join("|", controlsRequiringStyle) + @")\b([^>]*?)(/?>)",
          RegexOptions.IgnoreCase | RegexOptions.Singleline);

        // Pattern to check if Style attribute exists
        var styleAttributePattern = new Regex(
          @"\bStyle\s*=\s*""\s*\{(StaticResource|ThemeResource)",
          RegexOptions.IgnoreCase);

        // Pattern to check if element has x:Key (is a resource definition)
        var xKeyPattern = new Regex(@"\bx:Key\s*=", RegexOptions.IgnoreCase);

        // Pattern to check if element has x:Name starting with PART_ (template part)
        var templatePartPattern = new Regex(@"\bx:Name\s*=\s*""PART_", RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary files and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Templates") ||
              fileName.Contains("Dictionary"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip if this is a ResourceDictionary file
          if (content.Contains("<ResourceDictionary"))
            continue;

          // Track if we're inside a template or style definition
          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;
          var insideStyle = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template/style nesting
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            // Skip lines inside templates or style definitions
            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (xKeyPattern.IsMatch(line))
              continue;

            // Find control tags on this line
            var matches = controlTagPattern.Matches(line);
            foreach (Match match in matches)
            {
              var fullMatch = match.Value;
              var controlName = match.Groups[2].Value;
              var attributes = match.Groups[3].Value;

              // Skip if it's a template part
              if (templatePartPattern.IsMatch(fullMatch))
                continue;

              // Skip if it has x:Key
              if (xKeyPattern.IsMatch(fullMatch))
                continue;

              // Check if Style attribute is present with StaticResource or ThemeResource
              if (!styleAttributePattern.IsMatch(fullMatch))
              {
                violations.Add($"{filePath}({lineNum}): Control '<{controlName}>' is missing a Style attribute. Add Style=\"{{StaticResource {controlName}Style}}\" or Style=\"{{ThemeResource {controlName}Style}}\".");
              }
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Typography Validation: FontSize/FontFamily/FontWeight must use resources
    =============================================
  -->

  <Target Name="ValidateTypographyResources"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForTypographyValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                          Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlTypography
      XamlFiles="@(_XamlFilesForTypographyValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for hardcoded typography values
    Detects:
      - FontSize="14" (hardcoded numeric values)
      - FontFamily="Segoe UI" (hardcoded font names)
      - FontWeight="Bold" (hardcoded weight values)
    Allows:
      - FontSize="{StaticResource ...}" or "{ThemeResource ...}"
      - Values inside ResourceDictionary definitions
  -->
  <UsingTask TaskName="ValidateXamlTypography" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Pattern for hardcoded FontSize (numeric values)
        var fontSizePattern = new Regex(
          @"\bFontSize\s*=\s*""(\d+(\.\d+)?)""\s*",
          RegexOptions.IgnoreCase);

        // Pattern for hardcoded FontFamily (non-resource values)
        var fontFamilyPattern = new Regex(
          @"\bFontFamily\s*=\s*""([^{][^""]*)""\s*",
          RegexOptions.IgnoreCase);

        // Pattern for hardcoded FontWeight
        var fontWeightPattern = new Regex(
          @"\bFontWeight\s*=\s*""(Thin|ExtraLight|Light|SemiLight|Normal|Medium|SemiBold|Bold|ExtraBold|Black|ExtraBlack)""\s*",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary") ||
              fileName.Contains("Fonts"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template nesting (allowed to have hardcoded values in templates)
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            // Skip lines inside templates
            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Skip lines already using StaticResource or ThemeResource for typography
            if (Regex.IsMatch(line, @"Font(Size|Family|Weight)\s*=\s*""\s*\{(StaticResource|ThemeResource)", RegexOptions.IgnoreCase))
              continue;

            // Check for hardcoded FontSize
            var fontSizeMatches = fontSizePattern.Matches(line);
            foreach (Match match in fontSizeMatches)
            {
              violations.Add($"{filePath}({lineNum}): Hardcoded FontSize=\"{match.Groups[1].Value}\" detected. Use StaticResource or ThemeResource (e.g., FontSize=\"{{StaticResource BodyFontSize}}\").");
            }

            // Check for hardcoded FontFamily
            var fontFamilyMatches = fontFamilyPattern.Matches(line);
            foreach (Match match in fontFamilyMatches)
            {
              violations.Add($"{filePath}({lineNum}): Hardcoded FontFamily=\"{match.Groups[1].Value}\" detected. Use StaticResource or ThemeResource (e.g., FontFamily=\"{{StaticResource BodyFontFamily}}\").");
            }

            // Check for hardcoded FontWeight
            var fontWeightMatches = fontWeightPattern.Matches(line);
            foreach (Match match in fontWeightMatches)
            {
              violations.Add($"{filePath}({lineNum}): Hardcoded FontWeight=\"{match.Groups[1].Value}\" detected. Use StaticResource or ThemeResource (e.g., FontWeight=\"{{StaticResource BodyFontWeight}}\").");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Spacing Validation: Margin/Padding must use consistent spacing scale
    =============================================
  -->

  <Target Name="ValidateSpacingConsistency"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForSpacingValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                       Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlSpacing
      XamlFiles="@(_XamlFilesForSpacingValidation)"
      AllowedValues="$(UnoCodeStyleAllowedSpacingValues)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for consistent spacing values
    Detects:
      - Margin/Padding values not in the allowed spacing scale
    Default allowed values: 0,2,4,8,12,16,20,24,32,48,64
  -->
  <UsingTask TaskName="ValidateXamlSpacing" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <AllowedValues Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Parse allowed values
        var allowedSet = new HashSet<int>(
          AllowedValues.Split(',').Select(v => int.TryParse(v.Trim(), out var n) ? n : -1).Where(n => n >= 0)
        );

        // Pattern for Margin/Padding with numeric values
        var spacingPattern = new Regex(
          @"\b(Margin|Padding)\s*=\s*""([^""]+)""",
          RegexOptions.IgnoreCase);

        // Pattern to extract numeric values from spacing string
        var numberPattern = new Regex(@"-?\d+");

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template nesting
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key
            if (line.Contains("x:Key="))
              continue;

            // Skip lines using StaticResource or ThemeResource for spacing
            if (Regex.IsMatch(line, @"(Margin|Padding)\s*=\s*""\s*\{(StaticResource|ThemeResource)", RegexOptions.IgnoreCase))
              continue;

            // Find spacing declarations
            var matches = spacingPattern.Matches(line);
            foreach (Match match in matches)
            {
              var property = match.Groups[1].Value;
              var value = match.Groups[2].Value;

              // Extract all numeric values
              var numbers = numberPattern.Matches(value);
              var invalidValues = new List<int>();

              foreach (Match numMatch in numbers)
              {
                if (int.TryParse(numMatch.Value, out var num))
                {
                  var absNum = Math.Abs(num);
                  if (!allowedSet.Contains(absNum))
                  {
                    invalidValues.Add(num);
                  }
                }
              }

              if (invalidValues.Any())
              {
                var invalidStr = string.Join(", ", invalidValues.Distinct());
                violations.Add($"{filePath}({lineNum}): Non-standard {property} value(s): {invalidStr}. Use values from spacing scale: {AllowedValues}. Consider using StaticResource for consistent spacing.");
              }
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Accessibility Validation: Interactive controls must have AutomationProperties
    =============================================
  -->

  <Target Name="ValidateAccessibility"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForAccessibilityValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                              Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlAccessibility
      XamlFiles="@(_XamlFilesForAccessibilityValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for accessibility compliance
    Detects:
      - Interactive controls without AutomationProperties.Name or AutomationProperties.LabeledBy
    Exceptions:
      - Controls with text Content attribute (serves as accessible name)
      - Controls inside templates
  -->
  <UsingTask TaskName="ValidateXamlAccessibility" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Interactive controls that need accessible names
        var interactiveControls = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
          "Button", "RepeatButton", "ToggleButton", "HyperlinkButton", "DropDownButton",
          "SplitButton", "ToggleSplitButton", "AppBarButton", "AppBarToggleButton",
          "CheckBox", "RadioButton", "ToggleSwitch", "Slider", "ComboBox",
          "TextBox", "PasswordBox", "AutoSuggestBox", "NumberBox", "RichEditBox",
          "ListView", "GridView", "ListBox", "TreeView", "FlipView"
        };

        // Pattern to match interactive control tags
        var controlTagPattern = new Regex(
          @"<\s*(\w+:)?(" + string.Join("|", interactiveControls) + @")\b([^>]*?)(/?>)",
          RegexOptions.IgnoreCase | RegexOptions.Singleline);

        // Patterns for accessibility attributes
        var automationNamePattern = new Regex(@"AutomationProperties\.Name\s*=", RegexOptions.IgnoreCase);
        var automationLabeledByPattern = new Regex(@"AutomationProperties\.LabeledBy\s*=", RegexOptions.IgnoreCase);
        var contentPattern = new Regex(@"\bContent\s*=\s*""[^{][^""]+""", RegexOptions.IgnoreCase);
        var headerPattern = new Regex(@"\bHeader\s*=\s*""[^{][^""]+""", RegexOptions.IgnoreCase);
        var placeholderPattern = new Regex(@"\bPlaceholderText\s*=\s*""[^{][^""]+""", RegexOptions.IgnoreCase);
        var xKeyPattern = new Regex(@"\bx:Key\s*=", RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template nesting
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key
            if (xKeyPattern.IsMatch(line))
              continue;

            // Find interactive control tags
            var matches = controlTagPattern.Matches(line);
            foreach (Match match in matches)
            {
              var fullMatch = match.Value;
              var controlName = match.Groups[2].Value;

              // Check if it has AutomationProperties
              if (automationNamePattern.IsMatch(fullMatch) || automationLabeledByPattern.IsMatch(fullMatch))
                continue;

              // Check if it has Content/Header/PlaceholderText (acceptable fallback)
              if (contentPattern.IsMatch(fullMatch) || headerPattern.IsMatch(fullMatch) || placeholderPattern.IsMatch(fullMatch))
                continue;

              violations.Add($"{filePath}({lineNum}): Interactive control '<{controlName}>' is missing accessibility properties. Add AutomationProperties.Name=\"...\" for screen reader support.");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Responsive Design Validation: Pages should have responsive elements
    =============================================
  -->

  <Target Name="ValidateResponsiveDesign"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForResponsiveValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                          Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlResponsive
      XamlFiles="@(_XamlFilesForResponsiveValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML Pages/UserControls for responsive design awareness
    Detects:
      - Page or UserControl files without any responsive design elements
    Responsive elements include:
      - VisualStateManager with AdaptiveTrigger
      - ResponsiveView control
      - ResponsiveExtension markup
      - utu:Responsive attached properties
  -->
  <UsingTask TaskName="ValidateXamlResponsive" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary") ||
              fileName.Contains("Template"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Only check Page and UserControl files
          var isPage = Regex.IsMatch(content, @"<\s*(Page|UserControl)\b", RegexOptions.IgnoreCase);
          if (!isPage)
            continue;

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          // Check for responsive design elements
          var hasResponsiveElements = false;

          // Check for VisualStateManager with AdaptiveTrigger
          if (Regex.IsMatch(content, @"<\s*VisualStateManager", RegexOptions.IgnoreCase) &&
              Regex.IsMatch(content, @"<\s*AdaptiveTrigger", RegexOptions.IgnoreCase))
          {
            hasResponsiveElements = true;
          }

          // Check for ResponsiveView control
          if (Regex.IsMatch(content, @"<\s*(\w+:)?ResponsiveView\b", RegexOptions.IgnoreCase))
          {
            hasResponsiveElements = true;
          }

          // Check for ResponsiveExtension markup (utu:Responsive or toolkit:Responsive)
          if (Regex.IsMatch(content, @"\{(utu|toolkit):Responsive\b", RegexOptions.IgnoreCase))
          {
            hasResponsiveElements = true;
          }

          // Check for Responsive attached properties
          if (Regex.IsMatch(content, @"(utu|toolkit):Responsive\.", RegexOptions.IgnoreCase))
          {
            hasResponsiveElements = true;
          }

          // Check for StateTrigger or custom triggers that might be responsive
          if (Regex.IsMatch(content, @"<\s*StateTrigger\b", RegexOptions.IgnoreCase) &&
              Regex.IsMatch(content, @"(Width|Size|Breakpoint)", RegexOptions.IgnoreCase))
          {
            hasResponsiveElements = true;
          }

          if (!hasResponsiveElements)
          {
            violations.Add($"{filePath}(1): Page/UserControl has no responsive design elements. Consider using VisualStateManager with AdaptiveTrigger, ResponsiveView, or ResponsiveExtension for adaptive layouts. See: https://platform.uno/docs/articles/external/uno.toolkit.ui/doc/controls/ResponsiveView.html");
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Compiled Bindings Validation: Prefer x:Bind over Binding
    =============================================
  -->

  <Target Name="ValidateCompiledBindings"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForBindingValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                       Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlCompiledBindings
      XamlFiles="@(_XamlFilesForBindingValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for compiled bindings
    Detects:
      - {Binding ...} syntax (runtime binding)
    Recommends:
      - {x:Bind ...} (compile-time binding)
    Benefits of x:Bind:
      - Compile-time type checking
      - Better performance (no reflection)
      - IntelliSense support
      - Null safety
    See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html
  -->
  <UsingTask TaskName="ValidateXamlCompiledBindings" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Pattern for runtime Binding syntax (not x:Bind)
        var bindingPattern = new Regex(
          @"\{Binding\b([^}]*)\}",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files (Binding may be needed for generic styles)
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary") ||
              fileName.Contains("Generic"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideDataTemplate = 0;
          var insideControlTemplate = 0;
          var insideStyle = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template/style nesting - Binding may be acceptable in some template scenarios
            if (Regex.IsMatch(line, @"<\s*DataTemplate\b", RegexOptions.IgnoreCase))
              insideDataTemplate++;
            if (Regex.IsMatch(line, @"</\s*DataTemplate\s*>", RegexOptions.IgnoreCase))
              insideDataTemplate = Math.Max(0, insideDataTemplate - 1);

            if (Regex.IsMatch(line, @"<\s*ControlTemplate\b", RegexOptions.IgnoreCase))
              insideControlTemplate++;
            if (Regex.IsMatch(line, @"</\s*ControlTemplate\s*>", RegexOptions.IgnoreCase))
              insideControlTemplate = Math.Max(0, insideControlTemplate - 1);

            if (Regex.IsMatch(line, @"<\s*Style\b", RegexOptions.IgnoreCase))
              insideStyle++;
            if (Regex.IsMatch(line, @"</\s*Style\s*>", RegexOptions.IgnoreCase))
              insideStyle = Math.Max(0, insideStyle - 1);

            // Skip lines inside ControlTemplate or Style (Binding may be necessary for generic templates)
            if (insideControlTemplate > 0 || insideStyle > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Find {Binding ...} usage
            var matches = bindingPattern.Matches(line);
            foreach (Match match in matches)
            {
              var bindingContent = match.Groups[1].Value.Trim();
              var context = insideDataTemplate > 0 ? " (inside DataTemplate)" : "";

              // Extract the path if present for better error message
              var pathMatch = Regex.Match(bindingContent, @"Path\s*=\s*(\w+)|^(\w+)");
              var pathInfo = pathMatch.Success ? $" for '{pathMatch.Groups[1].Value}{pathMatch.Groups[2].Value}'" : "";

              violations.Add($"{filePath}({lineNum}): Use {{x:Bind}}{pathInfo} instead of {{Binding}}{context}. x:Bind provides compile-time type checking, better performance, and null safety. See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    Navigation Regions Validation: Navigation controls must use Region.Attached
    =============================================
  -->

  <Target Name="ValidateNavigationRegions"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForNavigationValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                          Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlNavigationRegions
      XamlFiles="@(_XamlFilesForNavigationValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML navigation controls for Region.Attached
    Detects:
      - NavigationView, TabBar, TabView, Frame without uen:Region.Attached
    Requires:
      - uen:Region.Attached="true" or Region.Attached="true"
    Benefits:
      - Uno Navigation extension support
      - Clean navigation architecture
      - Deep linking support
      - Back navigation handling
    See: https://platform.uno/docs/articles/external/uno.extensions/doc/Learn/Navigation/HowTo-NavigateInXAML.html
  -->
  <UsingTask TaskName="ValidateXamlNavigationRegions" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Navigation controls that should have Region.Attached
        var navigationControls = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
          "NavigationView", "TabBar", "TabView", "Frame", "ContentControl"
        };

        // Pattern to match navigation control tags
        var controlTagPattern = new Regex(
          @"<\s*(\w+:)?(" + string.Join("|", navigationControls) + @")\b([^>]*?)(/?>)",
          RegexOptions.IgnoreCase | RegexOptions.Singleline);

        // Pattern for Region.Attached attribute (with or without namespace prefix)
        var regionAttachedPattern = new Regex(
          @"(\w+:)?Region\.Attached\s*=\s*""[Tt]rue""",
          RegexOptions.IgnoreCase);

        // Pattern for Region.Name attribute (alternative valid config)
        var regionNamePattern = new Regex(
          @"(\w+:)?Region\.Name\s*=",
          RegexOptions.IgnoreCase);

        // Pattern for Region.Navigator attribute
        var regionNavigatorPattern = new Regex(
          @"(\w+:)?Region\.Navigator\s*=",
          RegexOptions.IgnoreCase);

        // Pattern to check if element has x:Key (is a resource definition)
        var xKeyPattern = new Regex(@"\bx:Key\s*=", RegexOptions.IgnoreCase);

        // Pattern to check if element has x:Name starting with PART_ (template part)
        var templatePartPattern = new Regex(@"\bx:Name\s*=\s*""PART_", RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary") ||
              fileName.Contains("Template"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          // Check if file uses Uno Extensions navigation namespace
          var hasNavigationNamespace = content.Contains("uno.extensions") ||
                                        content.Contains("uen:") ||
                                        content.Contains("Region.Attached") ||
                                        content.Contains("Region.Name");

          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template nesting
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            // Skip lines inside templates
            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (xKeyPattern.IsMatch(line))
              continue;

            // Find navigation control tags
            var matches = controlTagPattern.Matches(line);
            foreach (Match match in matches)
            {
              var fullMatch = match.Value;
              var controlName = match.Groups[2].Value;

              // Skip if it's a template part
              if (templatePartPattern.IsMatch(fullMatch))
                continue;

              // Skip if it has x:Key
              if (xKeyPattern.IsMatch(fullMatch))
                continue;

              // ContentControl needs more context - only flag if it looks like navigation container
              if (controlName.Equals("ContentControl", StringComparison.OrdinalIgnoreCase))
              {
                // Only flag ContentControl if it has navigation-related names or appears to be a navigation host
                if (!Regex.IsMatch(fullMatch, @"(x:Name|Name)\s*=\s*""[^""]*([Nn]avigat|[Cc]ontent|[Mm]ain|[Ss]hell|[Hh]ost)", RegexOptions.IgnoreCase))
                  continue;
              }

              // Check if it has Region.Attached, Region.Name, or Region.Navigator
              if (regionAttachedPattern.IsMatch(fullMatch) ||
                  regionNamePattern.IsMatch(fullMatch) ||
                  regionNavigatorPattern.IsMatch(fullMatch))
                continue;

              // For Frame specifically, suggest Region.Attached for navigation support
              var suggestion = controlName.Equals("Frame", StringComparison.OrdinalIgnoreCase)
                ? "Add uen:Region.Attached=\"true\" for Uno Navigation extensions support"
                : $"Add uen:Region.Attached=\"true\" or uen:Region.Name=\"...\" to '<{controlName}>' for proper navigation architecture";

              violations.Add($"{filePath}({lineNum}): Navigation control '<{controlName}>' is missing Region configuration. {suggestion}. See: https://platform.uno/docs/articles/external/uno.extensions/doc/Learn/Navigation/HowTo-NavigateInXAML.html");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    UNO0041: DataTemplate x:DataType Validation
    DataTemplates using x:Bind must have x:DataType for type-safe compiled bindings
    =============================================
  -->

  <Target Name="ValidateDataTemplateDataType"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForDataTypeValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                        Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlDataTemplateDataType
      XamlFiles="@(_XamlFilesForDataTypeValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate DataTemplates have x:DataType when using x:Bind
    Detects:
      - DataTemplate containing {x:Bind} without x:DataType attribute
    Requires:
      - x:DataType="namespace:TypeName" on DataTemplate when using x:Bind
    Benefits:
      - Enables compile-time type checking for bindings in templates
      - Better IntelliSense support
      - Catches binding errors at compile time instead of runtime
    See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html
  -->
  <UsingTask TaskName="ValidateXamlDataTemplateDataType" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);
          var lines = File.ReadAllLines(filePath);

          // Track DataTemplate blocks
          var dataTemplateStack = new Stack<(int startLine, bool hasDataType, bool hasXBind)>();

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Check for DataTemplate opening tag
            var dtOpenMatch = Regex.Match(line, @"<\s*DataTemplate\b([^>]*?)(/?>)", RegexOptions.IgnoreCase);
            if (dtOpenMatch.Success)
            {
              var attributes = dtOpenMatch.Groups[1].Value;
              var hasDataType = Regex.IsMatch(attributes, @"x:DataType\s*=", RegexOptions.IgnoreCase);
              var isSelfClosing = dtOpenMatch.Groups[2].Value == "/>";

              if (isSelfClosing)
              {
                // Self-closing DataTemplate - check if it has x:Bind in attributes (unlikely but possible)
                if (attributes.Contains("x:Bind") && !hasDataType)
                {
                  violations.Add($"{filePath}({lineNum}): DataTemplate uses {{x:Bind}} but is missing x:DataType attribute. Add x:DataType=\"namespace:YourType\" to enable compile-time type checking.");
                }
              }
              else
              {
                // Push onto stack to track the block
                dataTemplateStack.Push((lineNum, hasDataType, false));
              }
            }

            // Check for x:Bind inside current DataTemplate
            if (dataTemplateStack.Count > 0 && Regex.IsMatch(line, @"\{x:Bind\b", RegexOptions.IgnoreCase))
            {
              var current = dataTemplateStack.Pop();
              dataTemplateStack.Push((current.startLine, current.hasDataType, true));
            }

            // Check for DataTemplate closing tag
            if (Regex.IsMatch(line, @"</\s*DataTemplate\s*>", RegexOptions.IgnoreCase) && dataTemplateStack.Count > 0)
            {
              var template = dataTemplateStack.Pop();
              if (template.hasXBind && !template.hasDataType)
              {
                violations.Add($"{filePath}({template.startLine}): DataTemplate uses {{x:Bind}} but is missing x:DataType attribute. Add x:DataType=\"namespace:YourType\" to enable compile-time type checking. See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html");
              }
            }
          }

          // Check for any unclosed DataTemplates with x:Bind
          while (dataTemplateStack.Count > 0)
          {
            var template = dataTemplateStack.Pop();
            if (template.hasXBind && !template.hasDataType)
            {
              violations.Add($"{filePath}({template.startLine}): DataTemplate uses {{x:Bind}} but is missing x:DataType attribute. Add x:DataType=\"namespace:YourType\" to enable compile-time type checking.");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    UNO0045: Prefer Function Bindings Over Converters
    Suggests using x:Bind function bindings instead of IValueConverter
    =============================================
  -->

  <Target Name="ValidatePreferFunctionBindings"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForConverterValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                         Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlPreferFunctionBindings
      XamlFiles="@(_XamlFilesForConverterValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Suggest function bindings over IValueConverter
    Detects:
      - Bindings with Converter= attribute
    Suggests:
      - Using x:Bind with function syntax instead
    Benefits:
      - Simpler code (no converter class needed)
      - Better performance (direct method call)
      - Easier debugging (can set breakpoints)
      - Type safety at compile time
    Example:
      Before: Text="{x:Bind User.BirthDate, Converter={StaticResource DateConverter}}"
      After:  Text="{x:Bind local:Helpers.FormatDate(User.BirthDate)}"
    See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html#functions-in-binding-paths
  -->
  <UsingTask TaskName="ValidateXamlPreferFunctionBindings" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Pattern for bindings with Converter attribute
        var converterPattern = new Regex(
          @"\{(x:Bind|Binding)\b[^}]*\bConverter\s*=\s*\{(StaticResource|ThemeResource)\s+(\w+)\}",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideStyle = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track Style nesting (converters in styles are often intentional for reusability)
            if (Regex.IsMatch(line, @"<\s*Style\b", RegexOptions.IgnoreCase))
              insideStyle++;
            if (Regex.IsMatch(line, @"</\s*Style\s*>", RegexOptions.IgnoreCase))
              insideStyle = Math.Max(0, insideStyle - 1);

            // Skip lines inside Style definitions
            if (insideStyle > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Find bindings with Converter
            var matches = converterPattern.Matches(line);
            foreach (Match match in matches)
            {
              var bindingType = match.Groups[1].Value;
              var converterName = match.Groups[3].Value;

              violations.Add($"{filePath}({lineNum}): Consider using x:Bind with function syntax instead of Converter '{converterName}'. Example: {{x:Bind local:Converters.{converterName}(PropertyName)}}. See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html#functions-in-binding-paths");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    UNO0046: Warn on Object Type Binding
    Warns when x:Bind targets properties of type object that may need casting
    =============================================
  -->

  <Target Name="ValidateObjectTypeBindings"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForObjectBindingValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                              Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlObjectTypeBindings
      XamlFiles="@(_XamlFilesForObjectBindingValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Warn about potential object type binding issues
    Detects:
      - x:Bind accessing .Content, .DataContext, .Tag, .SelectedItem, .SelectedValue
        without explicit cast syntax
    These properties often return 'object' type and require casting for sub-property access
    Example:
      Problem:  Text="{x:Bind MyListView.SelectedItem.Name}" - fails if SelectedItem is object
      Solution: Text="{x:Bind ((local:MyType)MyListView.SelectedItem).Name}"
    See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html
  -->
  <UsingTask TaskName="ValidateXamlObjectTypeBindings" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Properties that typically return 'object' type
        var objectTypeProperties = new[] { "Content", "DataContext", "Tag", "SelectedItem", "SelectedValue", "CommandParameter", "Header", "Items" };

        // Pattern for x:Bind accessing object-type property with further property access
        // Matches: {x:Bind SomeControl.SelectedItem.PropertyName} without cast
        // Does NOT match: {x:Bind ((local:Type)SomeControl.SelectedItem).PropertyName} (has cast)
        var objectBindingPattern = new Regex(
          @"\{x:Bind\b[^}]*\b(\w+)\.(" + string.Join("|", objectTypeProperties) + @")\.(\w+)",
          RegexOptions.IgnoreCase);

        // Pattern to check if there's a cast present
        var castPattern = new Regex(
          @"\(\s*\([^)]+\)\s*\w+\.(" + string.Join("|", objectTypeProperties) + @")\s*\)",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Skip lines with x:Key (resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Skip if line contains a cast expression (user knows what they're doing)
            if (castPattern.IsMatch(line))
              continue;

            // Find potential object-type property access in x:Bind
            var matches = objectBindingPattern.Matches(line);
            foreach (Match match in matches)
            {
              var controlName = match.Groups[1].Value;
              var objectProperty = match.Groups[2].Value;
              var accessedProperty = match.Groups[3].Value;

              violations.Add($"{filePath}({lineNum}): x:Bind accesses '{objectProperty}.{accessedProperty}' which may fail if '{objectProperty}' returns type 'object'. Consider using cast syntax: ((local:YourType){controlName}.{objectProperty}).{accessedProperty}. See: https://platform.uno/docs/articles/features/windows-ui-xaml-xbind.html");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

  <!--
    =============================================
    No Hardcoded Sizing: Width/Height/CornerRadius/BorderThickness must use resources
    =============================================
  -->

  <Target Name="ValidateNoHardcodedSizing"
          BeforeTargets="BeforeBuild"
          Condition="'$(DesignTimeBuild)' != 'true'">

    <ItemGroup>
      <_XamlFilesForSizingValidation Include="$(MSBuildProjectDirectory)\**\*.xaml"
                                      Exclude="$(MSBuildProjectDirectory)\obj\**\*.xaml;$(MSBuildProjectDirectory)\bin\**\*.xaml" />
    </ItemGroup>

    <ValidateXamlNoHardcodedSizing
      XamlFiles="@(_XamlFilesForSizingValidation)"
      Severity="error" />
  </Target>

  <!--
    Inline Task: Validate XAML files for hardcoded sizing values
    Detects:
      - Width="200", Height="50" (hardcoded numeric values)
      - MinWidth, MinHeight, MaxWidth, MaxHeight with hardcoded values
      - CornerRadius="8" or CornerRadius="4,4,0,0"
      - BorderThickness="1" or BorderThickness="1,2,1,2"
    Allows:
      - {StaticResource ...} or {ThemeResource ...}
      - Auto (for Width/Height)
      - * or 2* (Grid star sizing)
      - NaN, Infinity
      - Values inside ResourceDictionary definitions
  -->
  <UsingTask TaskName="ValidateXamlNoHardcodedSizing" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <XamlFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Severity Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.IO" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Collections.Generic" />
      <Code Type="Fragment" Language="cs"><![CDATA[
        // Pattern for hardcoded Width/Height sizing (numeric values only)
        var sizingPattern = new Regex(
          @"\b(Width|Height|MinWidth|MinHeight|MaxWidth|MaxHeight)\s*=\s*""(\d+(\.\d+)?)""\s*",
          RegexOptions.IgnoreCase);

        // Pattern for hardcoded CornerRadius (numeric values)
        var cornerRadiusPattern = new Regex(
          @"\bCornerRadius\s*=\s*""(\d+(\.\d+)?(,\s*\d+(\.\d+)?)*)""\s*",
          RegexOptions.IgnoreCase);

        // Pattern for hardcoded BorderThickness (numeric values)
        var borderThicknessPattern = new Regex(
          @"\bBorderThickness\s*=\s*""(\d+(\.\d+)?(,\s*\d+(\.\d+)?)*)""\s*",
          RegexOptions.IgnoreCase);

        var violations = new List<string>();

        foreach (var file in XamlFiles)
        {
          var filePath = file.ItemSpec;
          var fileName = Path.GetFileName(filePath);

          // Skip ResourceDictionary and style files
          if (fileName.Contains("Resources") || fileName.Contains("Theme") ||
              fileName.Contains("Styles") || fileName.Contains("Dictionary") ||
              fileName.Contains("Sizes") || fileName.Contains("Dimensions"))
            continue;

          if (!File.Exists(filePath))
            continue;

          var content = File.ReadAllText(filePath);

          // Skip ResourceDictionary files
          if (content.Contains("<ResourceDictionary"))
            continue;

          var lines = File.ReadAllLines(filePath);
          var insideTemplate = 0;

          for (int i = 0; i < lines.Length; i++)
          {
            var line = lines[i];
            var lineNum = i + 1;

            // Track template nesting (allowed to have hardcoded values in templates)
            if (Regex.IsMatch(line, @"<\s*(DataTemplate|ControlTemplate|Style)\b", RegexOptions.IgnoreCase))
              insideTemplate++;
            if (Regex.IsMatch(line, @"</\s*(DataTemplate|ControlTemplate|Style)\s*>", RegexOptions.IgnoreCase))
              insideTemplate = Math.Max(0, insideTemplate - 1);

            // Skip lines inside templates
            if (insideTemplate > 0)
              continue;

            // Skip lines with x:Key (resource definitions)
            if (line.Contains("x:Key="))
              continue;

            // Skip lines already using StaticResource or ThemeResource for sizing
            if (Regex.IsMatch(line, @"(Width|Height|MinWidth|MinHeight|MaxWidth|MaxHeight)\s*=\s*""\s*\{(StaticResource|ThemeResource)", RegexOptions.IgnoreCase))
              continue;

            // Skip lines with Auto or star sizing for Width/Height
            if (Regex.IsMatch(line, @"(Width|Height)\s*=\s*""(Auto|\d*\*)""\s*", RegexOptions.IgnoreCase))
              continue;

            // Check for hardcoded Width/Height/Min*/Max*
            var sizingMatches = sizingPattern.Matches(line);
            foreach (Match match in sizingMatches)
            {
              var property = match.Groups[1].Value;
              var value = match.Groups[2].Value;
              violations.Add($"{filePath}({lineNum}): Hardcoded {property}=\"{value}\" detected. Use StaticResource or ThemeResource (e.g., {property}=\"{{StaticResource Standard{property}}}\").");
            }

            // Skip lines already using StaticResource or ThemeResource for CornerRadius
            if (Regex.IsMatch(line, @"CornerRadius\s*=\s*""\s*\{(StaticResource|ThemeResource)", RegexOptions.IgnoreCase))
              continue;

            // Check for hardcoded CornerRadius
            var cornerMatches = cornerRadiusPattern.Matches(line);
            foreach (Match match in cornerMatches)
            {
              var value = match.Groups[1].Value;
              violations.Add($"{filePath}({lineNum}): Hardcoded CornerRadius=\"{value}\" detected. Use StaticResource or ThemeResource (e.g., CornerRadius=\"{{StaticResource StandardCornerRadius}}\").");
            }

            // Skip lines already using StaticResource or ThemeResource for BorderThickness
            if (Regex.IsMatch(line, @"BorderThickness\s*=\s*""\s*\{(StaticResource|ThemeResource)", RegexOptions.IgnoreCase))
              continue;

            // Check for hardcoded BorderThickness
            var borderMatches = borderThicknessPattern.Matches(line);
            foreach (Match match in borderMatches)
            {
              var value = match.Groups[1].Value;
              violations.Add($"{filePath}({lineNum}): Hardcoded BorderThickness=\"{value}\" detected. Use StaticResource or ThemeResource (e.g., BorderThickness=\"{{StaticResource StandardBorderThickness}}\").");
            }
          }
        }

        foreach (var violation in violations)
        {
          if (Severity.Equals("error", StringComparison.OrdinalIgnoreCase))
            Log.LogError(violation);
          else
            Log.LogWarning(violation);
        }

        return !violations.Any() || !Severity.Equals("error", StringComparison.OrdinalIgnoreCase);
      ]]></Code>
    </Task>
  </UsingTask>

</Project>
